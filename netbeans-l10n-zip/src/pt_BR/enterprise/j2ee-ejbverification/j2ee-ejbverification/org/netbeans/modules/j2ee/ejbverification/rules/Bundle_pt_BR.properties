AnnotationPostContruct.description=Verifica o uso da anota\u00e7\u00e3o @PostConstruct. Seu valor de retorno, singularidade por classe, par\u00e2metros etc.
AnnotationPostContruct.display.name=Anota\u00e7\u00e3o @PostConstruct
AnnotationPostContruct_thrown_checked_exceptions=O m\u00e9todo @PostConstruct anotado n\u00e3o deve gerar uma exce\u00e7\u00e3o verificada.
AnnotationPostContruct_too_much_annotations=N\u00e3o pode haver mais de um m\u00e9todo @PostConstruct anotado
AnnotationPostContruct_wrong_parameters=O m\u00e9todo anotado @PostConstruct n\u00e3o deve ter nenhum par\u00e2metro, exceto no caso de interceptadores EJB. Nesse caso, o m\u00e9todo utiliza subclasses InvocationContext.
AnnotationPostContruct_wrong_return_type=O tipo de retorno do m\u00e9todo @PostConstruct anotado deve ser anulado.
AsynchronousMethodInvocation.description=Verifica o uso de @Asynchronous. Testa se ela ser\u00e1 usada dentro do projeto e do tipo de interface suportados.
AsynchronousMethodInvocation.display.name=Chamada do m\u00e9todo ass\u00edncrono
AsynchronousMethodInvocation.err.asynchronous.in.ejb31=N\u00e3o \u00e9 permitida a chamada do m\u00e9todo ass\u00edncrono em projeto que direciona o perfil Lite JavaEE 6
BeanHasDifferentLBIandRBI.display.name=Interface de neg\u00f3cios Local e Remota juntas
BeanHasDifferentLBIandRBI.err=A mesma interface comercial n\u00e3o pode ser uma interface comercial local e remota do Bean.
BeanImplementsBI.display.name=O bean n\u00e3o implementa a interface de neg\u00f3cios
BeanImplementsBI.err=Recomenda-se que uma classe de Bean implemente sua interface comercial.
BMnotPartOfRBIandLBI.display.name=Defini\u00e7\u00e3o do m\u00e9todo na interface local e remota
BMnotPartOfRBIandLBI.err=Quando um bean de sess\u00e3o possui interfaces de neg\u00f3cios local e remota, n\u00e3o deve haver qualquer m\u00e9todo comum a ambas as interfaces.
BusinessMethodExposed.display.name=M\u00e9todo n\u00e3o exposto na interface de neg\u00f3cios.
BusinessMethodExposed.hint=O m\u00e9todo n\u00e3o foi exposto em qualquer interface de neg\u00f3cios.
HasNoArgContructor.display.name=Construtor No-arg no bean EJB
HasNoArgContructor.err=A classe EJB deve ter um construtor sem argumento protegido ou p\u00fablico.
LegalModifiers.BeanClassMustBePublic=A classe EJB deve ser p\u00fablica
LegalModifiers.BeanClassNotBeAbstract=A classe EJB n\u00e3o deve ser abstrata
LegalModifiers.BeanClassNotBeFinal=A classe EJB n\u00e3o deve ser final
LegalModifiers.desc=Verifica se os beans EJB definidos t\u00eam modificadores corretos - s\u00e3o p\u00fablicos, n\u00e3o finais e n\u00e3o abstratos.
LegalModifiers.display.name=Modificadores do bean EJB
LocalAnnotatedBeanHasLBI.display.name=Bean de Sess\u00e3o de LBI incompleto
LocalAnnotatedBeanHasLBI.err=Se um Bean de sess\u00e3o for anotado como @Local, ele dever\u00e1 ter uma interface comercial local.
PersistentTimerInEjbLite.desc=O temporizador persistente (anota\u00e7\u00e3o @Schedule) n\u00e3o pode ser usado no caso do EJB 3.2 Lite e o temporizador n\u00e3o pode ser usado completamente dentro do EJB 3.1 que direciona o projeto.
PersistentTimerInEjbLite.display.name=Temporizador persistente dentro do EJB Lite
PersistentTimerInEjbLite.err.nonpersistent.timer.in.ee7lite=N\u00e3o \u00e9 permitido timer persistente em projeto que direciona o servidor do perfil Web JavaEE 7.
PersistentTimerInEjbLite.err.timer.in.ee6lite=N\u00e3o \u00e9 permitida @Schedule em projeto que direciona o servidor de perfil Web JavaEE 6.
PersistentTimerInEjbLiteFix.lbl.make.timer.nonpersistent=Tornar o temporizador n\u00e3o persistente
RemoteAnnotatedBeanHasRBI.display.name=Bean de Sess\u00e3o de RBI incompleto
RemoteAnnotatedBeanHasRBI.err=Se um Bean de sess\u00e3o for anotado como @Remote, ele dever\u00e1 ter uma interface comercial remota.
SBSuperClassNotSB.display.name=Heran\u00e7a de beans da sess\u00e3o
SBSuperClassNotSB.err=Um Bean de sess\u00e3o n\u00e3o deve estender outro bean de sess\u00e3o.
SessionSynchImplementedBySFSBOnly.display.name=SessionSynchronization implementado por n\u00e3o SFSB
SessionSynchImplementedBySFSBOnly.err=Somente o Bean de sess\u00e3o com estado (SFSB) pode implementar a interface SessionSynchronization
UseInjectionInsteadOfInstantionRule.desc=Encontra instancia\u00e7\u00f5es de um bean que pode ser injetado pela anota\u00e7\u00e3o @EJB
UseInjectionInsteadOfInstantionRule.display.name=Instancia\u00e7\u00e3o substitu\u00edvel por inje\u00e7\u00e3o de @EJB
UseInjectionInsteadOfInstantionRule.error=A instancia\u00e7\u00e3o do bean pode ser substitu\u00edda pela inje\u00e7\u00e3o de @EJB
UseInjectionInsteadOfInstantionRule.fix=Substituir Instancia\u00e7\u00e3o de um bean pela inje\u00e7\u00e3o de @EJB
ValueNotSpecifiedForRemoteAnnotationInterface.display.name=@Remote usa o valor na interface de neg\u00f3cios
ValueNotSpecifiedForRemoteAnnotationInterface.err=Se uma interface for anotada com @Remote, o atributo de valor n\u00e3o dever\u00e1 ser especificado. Em outras palavras, se o valor for especificado para @Remote, ele dever\u00e1 anotar uma classe (n\u00e3o uma interface).
WSisSLSB.display.name=O Web Service deve ser designado como bean da sess\u00e3o
WSisSLSB.err=Se uma classe \u00e9 parte do JAR do EJB e \u00e9 anotada como @WebService, ela deve ser designada como sem classe ou como um bean de sess\u00e3o singleton.

