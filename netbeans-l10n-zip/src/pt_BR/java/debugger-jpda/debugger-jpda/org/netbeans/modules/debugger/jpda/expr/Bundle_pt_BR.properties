# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
#
# Copyright 1997-2010 Oracle and/or its affiliates. All rights reserved.
#
# Oracle and Java are registered trademarks of Oracle and/or its affiliates.
# Other names may be trademarks of their respective owners.
#
# The contents of this file are subject to the terms of either the GNU
# General Public License Version 2 only ("GPL") or the Common
# Development and Distribution License("CDDL") (collectively, the
# "License"). You may not use this file except in compliance with the
# License. You can obtain a copy of the License at
# http://www.netbeans.org/cddl-gplv2.html
# or nbbuild/licenses/CDDL-GPL-2-CP. See the License for the
# specific language governing permissions and limitations under the
# License.  When distributing the software, include this License Header
# Notice in each file and include the License file at
# nbbuild/licenses/CDDL-GPL-2-CP.  Oracle designates this
# particular file as subject to the "Classpath" exception as provided
# by Oracle in the GPL Version 2 section of the License file that
# accompanied this code. If applicable, add the following below the
# License Header, with the fields enclosed by brackets [] replaced by
# your own identifying information:
# "Portions Copyrighted [year] [name of copyright owner]"
#
# Contributor(s):
#
# The Original Software is NetBeans. The Initial Developer of the Original
# Software is Sun Microsystems, Inc. Portions Copyright 1997-2006 Sun
# Microsystems, Inc. All Rights Reserved.
#
# If you wish your version of this file to be governed by only the CDDL
# or only the GPL Version 2, indicate your decision by adding
# "[Contributor] elects to include this software in this distribution
# under the [CDDL or GPL Version 2] license." If you do not indicate a
# single choice of license, a recipient has the option to distribute
# your version of this file under either the CDDL, the GPL Version 2 or
# to extend the choice of license to its licensees as provided above.
# However, if you add GPL Version 2 code and therefore, elected the GPL
# Version 2 license, then the option applies only if the new code is
# made subject to such option by the copyright holder.
#

CTL_UnsupportedOperationException=Chamada de m\u00e9todo n\u00e3o tem suporte.
CTL_EvalError_unsupportedStringCreation=A cria\u00e7\u00e3o de strings n\u00e3o \u00e9 suportada.
CTL_EvalError_unknownNonterminal = Erro do avaliador ao processar o n\u00f3 "{0}" (n\u00f3 desconhecido)
CTL_EvalError_internalError = N\u00e3o \u00e9 poss\u00edvel avaliar o n\u00f3 "{0}"
CTL_EvalError_invalidArrayInitializer = O valor "{0}" n\u00e3o pode ser utilizado em nenhum inicializador de array.
CTL_EvalError_arraySizeBadType = Especifica\u00e7\u00e3o de tamanho de array inv\u00e1lido: "{0}"
CTL_EvalError_notArrayType = N\u00e3o \u00e9 poss\u00edvel acessar como tipo de array: "{0}"
CTL_EvalError_arrayCreateError = Erro criando uma array: {0}
CTL_EvalError_instantiateInterface = O tipo "{0}" n\u00e3o pode ser instanciado, ele n\u00e3o \u00e9 uma classe concreta.
CTL_EvalError_castToBooleanRequired = N\u00e3o \u00e9 poss\u00edvel transmitir "{0}" para algo diferente de um booliano.
CTL_EvalError_castFromBooleanRequired = N\u00e3o \u00e9 poss\u00edvel transmitir "{0}" em um booliano.
CTL_EvalError_castError = N\u00e3o \u00e9 poss\u00edvel transmitir uma inst\u00e2ncia de "{0}" para uma inst\u00e2ncia de "{1}"
CTL_EvalError_badOperandForPostfixOperator = O operando "{0}" para o operador sufixo n\u00e3o \u00e9 num\u00e9rico.
CTL_EvalError_postfixOperatorEvaluationError = Erro ao avaliar o operador de sufixo: {0}
CTL_EvalError_badOperandForPrefixOperator = O operando "{0}" para o operador prefixo n\u00e3o \u00e9 num\u00e9rico.
CTL_EvalError_prefixOperatorEvaluationError = Erro ao avaliar o operador de prefixo: {0}
CTL_EvalError_badOperandForUnaryOperator = O operando "{0}" para o operador un\u00e1rio n\u00e3o \u00e9 num\u00e9rico.
CTL_EvalError_unaryOperatorEvaluationError = Erro ao avaliar operador un\u00e1rio: {0}
CTL_EvalError_unknownType = Tipo desconhecido "{0}"
CTL_EvalError_internalErrorResolvingType = Erro interno ao resolver tipo "{0}"
CTL_EvalError_instanceOfLeftOperandNotAReference = Tipo inv\u00e1lido de operando esquerdo para a inst\u00e2ncia de: "{0}" Somente tipos de refer\u00eancia s\u00e3o permitidos.
CTL_EvalError_conditionalOrAndBooleanOperandRequired = Tipo inv\u00e1lido para && ou || operador: "{0}" \u00c9 permitido somente tipo booliano.
CTL_EvalError_conditionalQuestionMarkBooleanOperandRequired = Tipo inv\u00e1lido para?: operador: "{0}" \u00c9 permitido somente tipo booliano.
CTL_EvalError_thisObjectUnavailable = O objeto "this" n\u00e3o est\u00e1 dispon\u00edvel em um contexto est\u00e1tico.
CTL_EvalError_objectReferenceRequiredOnDereference = N\u00e3o \u00e9 poss\u00edvel cancelar a refer\u00eancia "{0}". \u00c9 necess\u00e1ria uma refer\u00eancia ao objeto.
CTL_EvalError_badArgument = Argumento de m\u00e9todo inv\u00e1lido: {0}
CTL_EvalError_argumentsBadSyntax = Argumentos de m\u00e9todo inv\u00e1lidos: {0}
CTL_EvalError_ambigousMethod = N\u00e3o \u00e9 poss\u00edvel chamar o m\u00e9todo "{1}" na classe "{0}". A chamada \u00e9 amb\u00edgua.
CTL_EvalError_noSuchMethod = N\u00e3o existe o m\u00e9todo "{0}" na classe "{1}"
CTL_EvalError_noSuchMethodWithArgs = Nenhum dos m\u00e9todos "{0}" da classe "{1}" utiliza par\u00e2metros dos tipos "{2}".
CTL_EvalError_noSuchConstructorWithArgs = Nenhum dos construtores da classe "{0}" utiliza par\u00e2metros dos tipos "{1}".
CTL_EvalError_callException = Erro ao chamar o m\u00e9todo "{1}" na classe "{0}": {2}
CTL_EvalError_calleeException = O m\u00e9todo "{1}" na classe "{0}" gerou uma exce\u00e7\u00e3o: {2}
CTL_EvalError_identifierNotAReference = N\u00e3o \u00e9 poss\u00edvel cancelar a refer\u00eancia "{0}". \u00c9 necess\u00e1ria uma refer\u00eancia ao objeto.
CTL_EvalError_notarray = "{0}" n\u00e3o \u00e9 uma array, n\u00e3o \u00e9 poss\u00edvel indexar seu valor.
CTL_EvalError_arrayIndexNAN = O \u00edndice de array "{0}" n\u00e3o \u00e9 num\u00e9rico.
CTL_EvalError_arrayIndexOutOfBounds = O \u00edndice de array "{0}" est\u00e1 fora da faixa <0,{1}>
CTL_EvalError_unknownVariable = "{0}" n\u00e3o \u00e9 uma vari\u00e1vel conhecida no contexto atual.
CTL_EvalError_unknownVarNoDebugInfo = Informa\u00e7\u00f5es de vari\u00e1veis n\u00e3o est\u00e3o dispon\u00edveis; origem compilada sem a op\u00e7\u00e3o -g. O valor de "{0}" n\u00e3o \u00e9 conhecido.
CTL_EvalError_integerLiteralTooBig = O literal "{0}" inteiro \u00e9 muito grande. Utilize o sufixo L para valores longos.
CTL_EvalError_badFormatOfIntegerLiteral = N\u00e3o \u00e9 poss\u00edvel fazer parsing um literal num\u00e9rico "{0}" (muito grande?)
CTL_EvalError_unknownLiteralType = N\u00e3o \u00e9 poss\u00edvel fazer parsing literal "{0}"
CTL_EvalError_superUsedOnNonClass = O qualificador "super" pode ser utilizado somente com tipos de classe, n\u00e3o "{0}"
CTL_EvalError_evaluateError = N\u00e3o foi poss\u00edvel aplicar o operador "{0}" a "{1}" e "{2}".
CTL_EvalError_evaluateErrorUnary = N\u00e3o foi poss\u00edvel aplicar o operador un\u00e1rio \\"{0}\\" a \\"{1}\\".
CTL_EvalError_accessInstanceVariableFromStaticContext = N\u00e3o \u00e9 poss\u00edvel acessar a vari\u00e1vel de inst\u00e2ncia "{0}" no contexto est\u00e1tico.
CTL_EvalError_methodCallOnNull = O m\u00e9todo "{0}" chamado em um objeto nulo.
CTL_EvalError_invokeInstanceMethodAsStatic = N\u00e3o \u00e9 poss\u00edvel fazer refer\u00eancia ao m\u00e9todo n\u00e3o est\u00e1tico "{0}" de um contexto est\u00e1tico.
CTL_EvalError_fieldOnNull = Campo "{0}" referenciado em objeto nulo.
CTL_EvalError_cannotApplyOperator = O operador n\u00e3o pode ser aplicado: {0}
CTL_EvalError_invalidMemberReference = Refer\u00eancia inv\u00e1lida ao membro: "{0}"
CTL_EvalError_arrayIsNull = A array "{0}" \u00e9 um objeto nulo.
CTL_EvalError_unknownInternalError = N\u00e3o \u00e9 poss\u00edvel avaliar a express\u00e3o: erro interno "{0}".
CTL_EvalError_collected = O objeto foi coletado.
CTL_EvalError_unsupported = Express\u00e3o n\u00e3o suportada: "{0}"
CTL_EvalError_errorneous = Express\u00e3o incorreta: "{0}"
CTL_EvalError_unknownField = Campo desconhecido "{0}"
CTL_EvalError_unknownOuterClass = Classe externa desconhecida "{0}"
CTL_EvalError_notExpression = N\u00e3o h\u00e1 express\u00e3o a ser avaliada.
CTL_EvalError_methOnArray = N\u00e3o \u00e9 poss\u00edvel chamar qualquer m\u00e9todo em arrays.
CTL_EvalError_methOnInterface = N\u00e3o \u00e9 poss\u00edvel chamar m\u00e9todos est\u00e1ticos em interfaces.
CTL_EvalError_forEachNotApplicable = Para cada n\u00e3o aplic\u00e1vel para o tipo de express\u00e3o.
CTL_EvalError_localVariableAlreadyDefined = {0} j\u00e1 est\u00e1 definido.
CTL_EvalError_disconnected = O depurador est\u00e1 desconectado.
CTL_EvalError_collected_context = O thread de contexto foi coletado.
CTL_EvalError_canNotInvokeMethods = N\u00e3o foi poss\u00edvel avaliar as chamadas do m\u00e9todo.
CTL_EvalError_notABoolean = A express\u00e3o "{0}" n\u00e3o retornou um valor booliano, mas: {1} de tipo {2}.
CTL_EvalError_notAValue = N\u00e3o \u00e9 poss\u00edvel avaliar
CTL_EvalError_noNewClassWithBody = N\u00e3o suportada: n\u00e3o \u00e9 poss\u00edvel criar uma nova classe.
#CTL_EvalErrorExpr = Error in evaluation of expression \"{0}\": {1}.
MSG_IncompatibleThreadStateMessage=O thread atual n\u00e3o pode chamar m\u00e9todos.\nProvavelmente, n\u00e3o foi suspenso por um evento (ponto de interrup\u00e7\u00e3o, etapa etc.).

