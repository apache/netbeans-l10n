# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
#
# Copyright 1997-2010 Oracle and/or its affiliates. All rights reserved.
#
# Oracle and Java are registered trademarks of Oracle and/or its affiliates.
# Other names may be trademarks of their respective owners.
#
# The contents of this file are subject to the terms of either the GNU
# General Public License Version 2 only ("GPL") or the Common
# Development and Distribution License("CDDL") (collectively, the
# "License"). You may not use this file except in compliance with the
# License. You can obtain a copy of the License at
# http://www.netbeans.org/cddl-gplv2.html
# or nbbuild/licenses/CDDL-GPL-2-CP. See the License for the
# specific language governing permissions and limitations under the
# License.  When distributing the software, include this License Header
# Notice in each file and include the License file at
# nbbuild/licenses/CDDL-GPL-2-CP.  Oracle designates this
# particular file as subject to the "Classpath" exception as provided
# by Oracle in the GPL Version 2 section of the License file that
# accompanied this code. If applicable, add the following below the
# License Header, with the fields enclosed by brackets [] replaced by
# your own identifying information:
# "Portions Copyrighted [year] [name of copyright owner]"
#
# Contributor(s):
#
#The Original Software is NetBeans. The Initial Developer of the Original
# Software is Sun Microsystems, Inc. Portions Copyright 1997-2010 Sun
#Microsystems, Inc. All Rights Reserved.
#
# If you wish your version of this file to be governed by only the CDDL
# or only the GPL Version 2, indicate your decision by adding
# "[Contributor] elects to include this software in this distribution
# under the [CDDL or GPL Version 2] license." If you do not indicate a
# single choice of license, a recipient has the option to distribute
# your version of this file under either the CDDL, the GPL Version 2 or
# to extend the choice of license to its licensees as provided above.
# However, if you add GPL Version 2 code and therefore, elected the GPL
# Version 2 license, then the option applies only if the new code is
# made subject to such option by the copyright holder.

#
# This bundle defines the localized name of the module, as will be shown
# in the options dialog and the setup wizard, and the category folder it will
# be found in, in the options dialog under System | Modules
#


# Braces
LBL_Braces_For="For"-Schleifen m\u00fcssen Klammern verwenden
LBL_Braces_While="While"-Schleifen m\u00fcssen Klammern verwenden
LBL_Braces_DoWhile="Do-While"-Schleifen m\u00fcssen Klammern verwenden
LBL_Braces_If="If-Else"-Anweisungen m\u00fcssen Klammern verwenden

DSC_Braces_For=Warnt falls der Rumpf einer <CODE>for</CODE> Schleife<BR>nicht in geschweiften Klammern steht.<BR>
DSC_Braces_While="While"-Schleifen m\u00fcssen Klammern verwenden
DSC_Braces_DoWhile="Do-While"-Schleifen m\u00fcssen Klammern verwenden
DSC_Braces_If="If-Else"-Anweisungen m\u00fcssen Klammern verwenden

LBL_Braces_Fix=Klammern hinzuf\u00fcgen

# Assignment to itself
LBL_ATI=Zuweisung auf sich selbst
DSC_ATI=Zuweisung auf sich selbst

LBL_ATI_Remove_FIX=Zuweisung entfernen
LBL_ATI_Qualify_FIX=Mit "this" qualifizieren
LBL_ATI_NewParameter_FIX=Parameter einf\u00fchren
LBL_ATI_NewField_FIX=Feld einf\u00fchren

# Imports
LBL_Imports_DELEGATE=Delegieren - nicht-GUI
LBL_Imports_UNUSED=Unn\u00f6tiger Import
LBL_Imports_DUPLICATE=Merhfacher Import
LBL_Imports_SAME_PACKAGE=Import aus dem selben Package
LBL_Imports_DEFAULT_PACKAGE=Import aus dem Package java.lang
LBL_Imports_EXCLUDED=Import aus Ausschlu\u00df
LBL_Imports_STAR=Stern-Import

DSC_Imports_DELAGATE=Delegieren - nicht-GUI
DSC_Imports_UNUSED=Unn\u00f6tiger Import
DSC_Imports_DUPLICATE=Merhfacher Import
DSC_Imports_SAME_PACKAGE=Import aus dem selben Package
DSC_Imports_DEFAULT_PACKAGE=Import aus dem Package java.lang
DSC_Imports_EXCLUDED=Import aus einem Paket oder einer Klasse, welche(s) in der Vervollst\u00e4ndigung bei den Ausschl\u00fc\u00dfen eingetragen ist.
DSC_Imports_STAR=Stern-Import

LBL_Imports_Fix_One_SAME_PACKAGE=Entfernen des Imports aus dem selbem Package
LBL_Imports_Fix_All_SAME_PACKAGE=Alle Importe aus dem selben Package entfernen

LBL_Imports_Fix_One_DEFAULT_PACKAGE=Entfernen des Import aus dem Package java.lang
LBL_Imports_Fix_All_DEFAULT_PACKAGE=Alle Importe aus dem Package java.lang entfernen

# equals and hashcode
MSG_MissingHashCode=Fehlende hashCode- oder equals-Methoden erzeugen
HINT_MissingHashCode=Pr\u00fcft ob eine Klasse, welche die equals()-Methode \u00fcberschreibt auch, die Methode hashCode() \u00fcberschreibt.
MSG_GenHashCode=Fehlende hashCode()-Methode erzeugen
MSG_GenEquals=Fehlende equals(Object)-Methode erzeugen

# export non accessible element
MSG_ExportNonAccessibleElement=Nicht-\u00d6ffentlicher Typ wird durch \u00f6ffentliche API exportiert
MSG_ExportNonAccessibleElementMakeNonVisible=Package-Private machen
HINT_ExportNonAccessibleElement=Pr\u00fcft, ob R\u00fcckgabewerte und Parametertypen aller \u00f6ffentlichen (public) Methoden und Felder von anderen Packages aus verf\u00fcgbar sind. Private oder Package-Private Typen in Package-APIs sind sinnlos.


# Annotation as super interface
# {0} name of the annotation
LBL_AnnotationAsSuperInterface=Annotation nicht als Superschnittstelle benutzen
HNT_AnnotationAsSuperInterface=Annotation {0} nicht als Superschnittstelle benutzen
DSC_AnnotationAsSuperInterface=Auch wenn der Compiler derartige Konstrukte erlaubt, sollten Annotations nicht als Superinterfaces verwendet werden.

# Utility class
MSG_UtilityClass=Hilfsklasse ohne Konstruktor
HINT_UtilityClass=Stellt fest, ob eine Klasse nur statische Methoden enth\u00e4lt und trotzdem instanziierbar ist.
MSG_PrivateConstructor=Privaten Konstruktor erzeugen
MSG_MakePrivate=Konstruktor "private" machen
MSG_PublicConstructor=Hilfsklasse mit sichtbarem Konstruktor
HINT_PublicConstructor=Stellt fest, ob eine Klasse nur statische Methoden und \u00f6ffentliche oder gesch\u00fctzte Konstruktoren enth\u00e4lt.

#Standard Javac warnings
LBL_Javac_DEPRECATED=Veraltet
LBL_Javac_UNCHECKED=Ungepr\u00fcft
LBL_Javac_FALLTHROUGH=Durchlauf
LBL_Javac_SERIALIZATION=Serialisierung
LBL_Javac_UNNECESSARY_CAST=Unn\u00f6tiger Cast
LBL_Javac_EMPTY_STATEMENT_AFTER_IF=Leere Anweisung nach "If"
LBL_Javac_OVERRIDES=\u00dcberschreibt
LBL_Javac_DIVISION_BY_ZERO=Division durch Null
LBL_Javac_RAWTYPES=Nicht parametrisierte Typen
LBL_Javac_CAN_USE_DIAMOND=Kann Diamantoperator nutzen

DSC_Javac_DEPRECATED=Warnung, wenn der Code veraltete APIs verwendet.
DSC_Javac_UNCHECKED=Warnung, wenn nicht \u00fcberpr\u00fcfte Konvertierungen zur Laufzeit ClassCastExceptions hervorrufen k\u00f6nnen.
DSC_Javac_FALLTHROUGH=Warnung, wenn eine "case"-Anweisung zur n\u00e4chsten durchl\u00e4uft.
DSC_Javac_SERIALIZATION=Warnung, wenn eine Klasse keine serialVersionUID hat, obwohl sie java.io.Serializable implementiert.
DSC_Javac_FINALLY=Warnung, wenn der "finally"-Block den Fluss des "try/catch"-Blocks unterbricht.
DSC_Javac_UNNECESSARY_CAST=Warnung, wenn ein Objekt unn\u00f6tigerweise in den gleichen Typen oder einen Supertypen gecastet wird.
DSC_Javac_EMPTY_STATEMENT_AFTER_IF=Leere Anweisung nach "If"
DSC_Javac_OVERRIDES=Warnung, wenn einer \u00fcberschreibenden Methode die Annotation "@Override" fehlt.
DSC_Javac_DIVISION_BY_ZERO=Division durch Null
DSC_Javac_RAWTYPES=Nicht parametrisierte Typen
DSC_Javac_CAN_USE_DIAMOND=Warnt an Stellen, an welchen der Diamantoperator des JDK7 anstelle von expliziten Typparametern verwendet werden kann.

# double check
MSG_DoubleCheck=Doppelt gepr\u00fcfte Sperre
HINT_DoubleCheck=Sucht nach dem Auftreten von doppelt gepr\u00fcften Sperren - z.B. ob eine Variable vor und in einem synchronisierten Block gepr\u00fcft wird.
ERR_DoubleCheck=Doppelt gepr\u00fcfte Sperre
FIX_DoubleCheck=\u00c4ussere bedingte Anweisung entfernen

LBL_IllegalInstanceOf=Falsche Benutzung des "instanceOf"-Operators
DSC_IllegalInstanceOf=Zeigt die falsche Benutzung von "instanceof" auf "javax.lang.model.elements", "javax.lang.model.type" und "com.sun.source.tree" an
MSG_IllegalInstanceOf=Falsche Benutzung von "instanceOf"

#Wrong string comparison
LBL_WrongStringComparison=Vergleich von Zeichenketten mit == oder !=
DSC_WrongStringComparison=Pr\u00fcft auf die Benutzung des "==" oder "!=" Operators f\u00fcr den Vergleich von Zeichenketten (Strings).<BR>Ein Zeichenkettenvergleich sollte immer \u00fcber die equals()-Methode vorgenommen werden.

FIX_WrongStringComparison_NullCheck=Benutzung von equals() mit null-Pr\u00fcfung
FIX_WrongStringComparison_TernaryNullCheck=Benutzung von equals() mit null-Pr\u00fcfung (tern\u00e4r)
FIX_WrongStringComparison_NoNullCheck=equals() verwenden
FIX_WrongStringComparison_ReverseOperands=equals() und Reversivoperanden verwenden

WrongStringComparisonCustomizer.ternaryNullCheck.text=Pr\u00fcfung auf "null" mit dem Tern\u00e4roperator
WrongStringComparisonCustomizer.stringLiteralFirst.text=Zeichenkettenliterale zuerst verwenden, wenn m\u00f6glich
ACSD_Ternary_Null_Check=Legt fest, ob die Korrektur eine bedingte Pr\u00fcfung auf "null" mit dem Tern\u00e4roperator durchf\u00fchrt.
ACSD_String_Literals_First=Erzeugt durch das Auslassen der Null-Pr\u00fcfung weniger Code, falls einer der Operanden ein Zeichenkettenliteral ist.

#Empty statements
LBL_Empty_FOR_LOOP=Leere Anweisung nach "for"
LBL_Empty_ENHANCED_FOR_LOOP=Leere Anweisung nach "for"
LBL_Empty_WHILE_LOOP=Leere Anweisung nach "while"
LBL_Empty_DO_WHILE_LOOP=Leere Anweisung nach "do"
LBL_Empty_IF=Leere Anweisung nach "if/else"
LBL_Empty_BLOCK=Leere Anweisung

DSC_Empty_FOR_LOOP=Pr\u00fcft auf 'for'-Anweisungen in der Form<BR><CODE>for(...);</CODE>.
DSC_Empty_WHILE_LOOP=Pr\u00fcft auf 'while'-Anweisungen in der Form<BR><CODE>while(...);</CODE>.
DSC_Empty_DO_WHILE_LOOP=Pr\u00fcft auf 'do/while'-Anweisungen in der Form<BR><CODE>do;<BR>while</CODE>.
DSC_Empty_IF=Pr\u00fcft auf 'if/else'-Anweisungen in der Form<BR><CODE>if(...);<BR>else;</CODE>.
DSC_Empty_BLOCK=Pr\u00fcft auf leere Anweisungen in Bl\u00f6cken; normalerweise durch \u00fcberfl\u00fcssige Semikola gekennzeichnet.

MSG_HiddenField=Feld \u00fcberdeckt ein anderes Feld
HINT_HiddenField=Die Deklaration eines Feldes kann die Deklaration eines anderen Feldes in der Superklasse \u00fcberdecken. Auch wenn dies m\u00f6glich ist, stellt es doch einen schlechten Programmierstil dar.
MSG_FixHiddenFiledText=Feld umbenennen
MSG_FixHiddenByVariableFiledText=Lokale Variable umbennenen
MSG_HiddenFieldByVar=Lokale Variable \u00fcberdeckt ein Feld
HINT_HiddenFieldByVar=Die Deklaration einer Variablen in einer Methode kann die Deklaration eines Feldes in der einschlie\u00dfenden Klasse \u00fcberdecken. Auch wenn dies m\u00f6glich ist, stellt es doch einen schlechten Programmierstil dar.

LBL_EmptyCancel=Leere cancel()-Methode f\u00fcr abbrechbare Aufgaben
DSC_EmptyCancel=Warnung zu leeren cancel()-Methoden f\u00fcr eine abbrechbare Aufgabe
MSG_EmptyCancel=Leeres cancel()

#{0}:
#     0 - field
#     1 - method
#     2 - other (unknown)
#{1}: element simple name
MSG_StaticAccess=Zugriff auf {0,choice,0#statisches Feld|1#statische Methode|1<element} {1}
MSG_StaticAccessName=Zugriff auf statisches Feld via Referenz
HINT_StaticAccess=Java erlaubt den Zugriff auf statische Felder \u00fcber Instanzvariablen, dies ist aber oft irref\u00fchrend und schwerer zu lesen.
MSG_StaticAccessText=Durch Klassenreferenz ersetzen

#ConvertAnonymousToInner:
HINT_ConvertAnonymousToInner=Anonymes Element zu Mitglied konvertieren
DN_ConvertAnonymousToInner=Anonymes Element zu Mitglied konvertieren
DESC_ConvertAnonymousToInner=Anonymes Element zu Mitglied konvertieren
FIX_ConvertAnonymousToInner=Anonymes Element zu Mitglied konvertieren

ERR_CaretNotInAnonymousInnerclass=Einf\u00fcgemarke ist nicht in anonymer Klasse.
ERR_SelectionNotSupported=Auswahl nicht unterst\u00fctzt.

CTL_ConvertAnonymousToInner=&Anonymes Element zu Mitglied konvertieren

HINT_AddOverrideAnnotation=@Override-Annotation hinzuf\u00fcgen
DN_AddOverrideAnnotation=@Override-Annotation hinzuf\u00fcgen
DESC_AddOverrideAnnotation=@Override-Annotation hinzuf\u00fcgen
FIX_AddOverrideAnnotation=@Override-Annotation hinzuf\u00fcgen

HINT_AssignResultToVariable=Den R\u00fcckgabewert einer Variablen zuweisen
DN_AssignResultToVariable=Den R\u00fcckgabewert einer Variablen zuweisen
DESC_AssignResultToVariable=Den R\u00fcckgabewert einer Variablen zuweisen
FIX_AssignResultToVariable=Den R\u00fcckgabewert einer Variablen zuweisen

HINT_WrongPackage=Inkorrektes Package
DN_WrongPackage=Falsches Package
DESC_WrongPackage=Falsches Package
#{0}:
#    0: Remove package
#    1: Change package
#{1}: target package name
FIX_WrongPackageFix={0,choice,0#Package-Deklaration entfernen|1#Package-Deklaration zu {1} \u00e4ndern}
FIX_WrongPackageMove=Klasse in korrektes Verzeichnis verschieben
ERR_CannotMoveAlreadyExists=Kann Quellen nicht verschieben - Der Zielpfad ist bereits vorhanden, ist aber kein Verzeichnis.
ERR_CannotMove=Kann Quellen nicht verschieben.

HINT_SuspiciousNamesCombination=Verd\u00e4chtige Namenskombination
DN_SuspiciousNamesCombination=Verd\u00e4chtige Namenskombination
DESC_SuspiciousNamesCombination=Verd\u00e4chtige Namenskombination

ERR_EQUALS_NOT_CHECKING_TYPE=Die Methode .equals() pr\u00fcft den Typ ihrer Parameter nicht

DN_FieldUnusedParam=Ungenutzten Konstruktorparameter einem Feld zuweisen
DSC_FieldUnusedParam=Ungenutzten Konstruktorparameter einem Feld zuweisen
FIX_AssignToExisting=Zu existierendem Feld zuweisen
FIX_CreateField=Feld erzeugen
ERR_UnusedParameter=Unbenutzter Parameter


DSC_EqualsMethod=Die Implementierung der Methode equals pr\u00fcft den Typ der Eingabeparameter nicht.
DN_EqualsMethod=Methode .equals pr\u00fcft die Typen nicht
FIX_CreateDeclaration=Deklaration erzeugen
DN_DeclarationForInstanceof=Deklaration f\u00fcr instanceof
ERR_DeclarationForInstanceof=Deklaration f\u00fcr instanceof

DSC_SynchronizationOnNonFinalField=Synchronisation auf einem nicht-"final" Feld
ERR_SynchronizationOnNonFinalField=Synchronisation auf einem nicht-"final" Feld
DN_SynchronizationOnNonFinalField=Synchronisation auf einem nicht-"final" Feld

HINT_SerialVersionUID=Standardm\u00e4ssige serialVersionUID hinzuf\u00fcgen
HINT_SerialVersionUID_Generated=Erzeugte serialVersionUID hinzuf\u00fcgen

FieldForUnusedParamCustomizer.finalFields.text=<html>Die Felder sind <code>final</code></html>
ACSD_Final_Fields=Felder, die durch diesen Hinweis erzeugt werden "final" machen.

DSC_StaticImport=Methode in statischen Import umwandeln. Feedback an http://www.netbeans.org/issues/show_bug.cgi?id=89258
DN_StaticImport=Statische Importe
ERR_StaticImport=Methode in statischen Import umwandeln
HINT_StaticImport={0} in statischen Import umwandeln
HINT_StaticImport2=Statischen Import f\u00fcr {0} hinzuf\u00fcgen

DN_StringBuilderAppend=Zeichenverkettung in StringBuilder.append
DESC_StringBuilderAppend=Sucht nach Zeichenverkettungen in der Parameterliste der append-Methode von StringBuilder oder StringBuffer.
ERR_StringBuilderAppend=Zeichenverkettung in "append" von {0}
FIX_StringBuilderAppend=Es ist besser eine Reihe von "appends" anstelle einer Zeichenverkettung zu verwenden.

#ThisIsAnonymous hint
DN_org.netbeans.modules.java.hints.ThisInAnonymous=Synchronisierung auf "this" in anonymer Klasse
DESC_org.netbeans.modules.java.hints.ThisInAnonymous=<html>Synchronisierung auf <tt>this</tt> in anonymen oder lokalen Klassen ist meist das Resultat einer \u00dcberarbeitung und wahrscheinlich ein Fehler.
ERR_ThisInAnonymous=Synchronisierung auf "this" in anonymer Klasse
ERR_ThisInAnonymousLocal=Synchronisierung auf "this" in lokaler Klasse
FIX_ThisInAnonymous=Synchronisierung auf "this" in einschlie\u00dfender Klasse

#LoggerNotStaticFinal hint
DN_org.netbeans.modules.java.hints.LoggerNotStaticFinal=Die Loggerdeklaration ist nicht "static final"
DESC_org.netbeans.modules.java.hints.LoggerNotStaticFinal=Jede Klasse sollte nur einen einzigen Logger haben. Wenn er als Feld definiert ist, sollte dieses "static final" sein.
MSG_LoggerNotStaticFinal_checkLoggerDeclaration=Das Deklarationsfeld {0} f\u00fcr den Logger sollte "static final" sein
MSG_LoggerNotStaticFinal_checkLoggerDeclaration_fix=Feld {0} "static final" setzen

#MultipleLoggers hint
DN_org.netbeans.modules.java.hints.MultipleLoggers=Mehrere Logger
DESC_org.netbeans.modules.java.hints.MultipleLoggers=In einer einzelnen Klasse sind mehrere Logger definiert.
MSG_MultipleLoggers_checkMultipleLoggers=Mehrere Logger ({0}) in Klasse {1} definiert

#NoLoggers hint
DN_org.netbeans.modules.java.hints.NoLoggers=Keine Logger
DESC_org.netbeans.modules.java.hints.NoLoggers=F\u00fcr diese Klasse wurde kein Logger definiert.
MSG_NoLoggers_checkNoLoggers=F\u00fcr Klasse {0} wurde kein Logger definiert.
MSG_NoLoggers_checkNoLoggers_Fix=Loggerfeld in Klasse {0} erzeugen

#ShiftOutOfRange hint
DN_org.netbeans.modules.java.hints.ShiftOutOfRange=Shift-Operation au\u00dferhalb der sinnvollen Grenze
DESC_org.netbeans.modules.java.hints.ShiftOutOfRange=Findet Shift-Operation bei denen der Shiftwert eine Konstante ist und sich au\u00dferhalb der sinnvollen Grenzen bewegt. Die Grenzen f\u00fcr Integershifts sind 0..31, f\u00fcr Longshifts bei 0..63. Alles au\u00dferhalb dieser Grenzen wird angezeigt. Die Bitverschiebung mit negativen oder \u00fcbergro\u00dfen Zahlen ist h\u00f6chstwahrscheinlich ein Programmierfehler.
MSG_ShiftOutOfRange_int=Shift-Operation au\u00dferhalb der sinnvollen Grenze 0..31
MSG_ShiftOutOfRange_long=Shift-Operation au\u00dferhalb der sinnvollen Grenze 0..63

#ClassStructure hints
DN_org.netbeans.modules.java.hints.ClassStructure.finalClass=Klasse ist "final"
DESC_org.netbeans.modules.java.hints.ClassStructure.finalClass=Findet Klassen die als "final" deklariert sind. Einige Programmierstandards raten von "finalen" Klassen ab.
MSG_FinalClass=Klasse {0} ist "final"
FIX_RemoveFinalFromClass="final" aus der Deklaration von Klasse {0} entfernen
DN_org.netbeans.modules.java.hints.ClassStructure.finalMethod=Methode ist "final"
DESC_org.netbeans.modules.java.hints.ClassStructure.finalMethod=Findet Methoden die als "final" deklariert sind. Einige Programmierstandards raten von "finalen" Klassen ab.
MSG_FinalMethod=Die Methode {0} ist als "final" deklariert
FIX_RemoveFinalFromMethod="final" aus der Deklaration der Methode {0} entfernen
DN_org.netbeans.modules.java.hints.ClassStructure.finalPrivateMethod=Private Methode ist "final"
DESC_org.netbeans.modules.java.hints.ClassStructure.finalPrivateMethod=Findet Methoden die als "final" und "private" deklariert sind. "Privat"e Methoden k\u00f6nnen nicht wirklich \u00fcberschrieben werden, daher ist eine Deklaration als "final" \u00fcberfl\u00fcssig.
MSG_FinalPrivateMethod=Private Methode {0} ist "final"
DN_org.netbeans.modules.java.hints.ClassStructure.finalStaticMethod="final static" Methode
DESC_org.netbeans.modules.java.hints.ClassStructure.finalStaticMethod=Findet Methoden, die "final" und "static" deklariert sind. Statische Methoden k\u00f6nnen nicht wirklich \u00fcberschrieben werden, daher ist eine Deklaration als "final" \u00fcberfl\u00fcssig.
MSG_FinalStaticMethod=Die statische Methode {0} ist als "final" deklariert
DN_org.netbeans.modules.java.hints.ClassStructure.finalMethodInFinalClass="final" Methode in "final" Klasse
DESC_org.netbeans.modules.java.hints.ClassStructure.finalMethodInFinalClass=Findet als "final" deklarierte Methoden in "final" Klassen. Das ist \u00fcberfl\u00fcssig und kann verwirrend sein.
MSG_FinalMethodInFinalClass=Die Methode {0} ist in einer "final" Klasse als "final" deklariert
DN_org.netbeans.modules.java.hints.ClassStructure.noopMethodInAbstractClass=Funktionslose Methode in abstrakter Klasse
DESC_org.netbeans.modules.java.hints.ClassStructure.noopMethodInAbstractClass=Findet funktionslose Methoden in abstrakten Klassen. Normalerweise ist es besser solche Methoden als "abstract" zu deklarieren, damit implementierende Klassen nicht vergessen, eine eigene Implementierung zu liefern.
MSG_NoopMethodInAbstractClass=Funktionslose Methode {0} sollte "abstract" sein
DN_org.netbeans.modules.java.hints.ClassStructure.publicConstructorInNonPublicClass=\u00d6ffentlicher Konstruktor in nicht-\u00f6ffentlicher Klasse
DESC_org.netbeans.modules.java.hints.ClassStructure.publicConstructorInNonPublicClass=Findet \u00f6ffentlich zugreifbare Konstruktoren in Klassen, die nicht \u00f6ffentlich sind.
MSG_PublicConstructorInNonPublicClass=Konstruktor ist \u00f6ffentlich in nicht-\u00f6ffentlicher Klasse
FIX_RemovePublicFromConstructor=Entfernen von "public" aus der Konstruktordeklaration
DN_org.netbeans.modules.java.hints.ClassStructure.protectedMemberInFinalClass="protected" Feld in "final" Klasse
DESC_org.netbeans.modules.java.hints.ClassStructure.protectedMemberInFinalClass=Findet Felder in als "final" deklarierten Klassen, die "protected" sind. Solche Felder sollten als "private" oder "package-private" deklariert werden.
MSG_ProtectedMethodInFinalClass=Die Methode {0} ist in einer "final" Klasse als "protected" deklariert
MSG_ProtectedFieldInFinalClass=Das Feld {0} ist in einer "final" Klasse als "protected" deklariert
FIX_RemoveProtectedFromMethod=Entfernen von "protected" aus der Deklaration von Methode {0}
FIX_RemoveProtectedFromField=Entfernen von "protected" aus der Deklaration von Feld {0}
DN_org.netbeans.modules.java.hints.ClassStructure.markerInterface=Marker-Interface
DESC_org.netbeans.modules.java.hints.ClassStructure.markerInterface=Findet Marker-Interfaces, die weder Methoden, noch Felder haben. Derartige Interfaces sind verwirrend und deuten normalerweise auf Designfehler hin. Interfaces, die zwei oder mehr andere Interfaces erweitern, werden nicht ausgewiesen.
MSG_MarkerInterface=Marker-Interface {0}
DN_org.netbeans.modules.java.hints.ClassStructure.classMayBeInterface=Klasse sollte Interface sein
DESC_org.netbeans.modules.java.hints.ClassStructure.classMayBeInterface=Findet alle konkreten oder abstrakten Klassen, die eventuell Interfaces sein sollten. Dies ist gegeben, wenn die Klasse keine weiteren Superklasen (ausser Object) hat, keine Felder hat, die nicht "static", "final" und "public" sind, keine Methoden deklariert, die nicht "public" und "abstract" sind und keine inneren Klassen aufweist, die nicht selber Interfaces sein k\u00f6nnen oder sind.
MSG_ClassMayBeInterface=Klasse {0} sollte Interface sein
FIX_ConvertClassToInterface=Klasse {0} zu Interface machen
DN_org.netbeans.modules.java.hints.ClassStructure.multipleTopLevelClassesInFile=Mehrere Top-Level Klassen in einer Datei
DESC_org.netbeans.modules.java.hints.ClassStructure.multipleTopLevelClassesInFile=Findet Dateien, die mehrere Top-Level Klassen enthalten. Mehrere Top-Level Klassen in einer Datei k\u00f6nnen verwirrend sein und den Nutzen verschiedener Softwaretools einschr\u00e4nken.
MSG_MultipleTopLevelClassesInFile=Mehrere Top-Level Klassen in einer Datei

#AssignmentIssues hints
DN_org.netbeans.modules.java.hints.AssignmentIssues.assignmentToForLoopParam=Zuweisung auf Parameter einer for-Schleife
DESC_org.netbeans.modules.java.hints.AssignmentIssues.assignmentToForLoopParam=Findet Zuweisungen auf Parameter einer for-Schleife im Rumpf dieser Schleife. Daneben werden auch Inkremente und Dekremente der Varaiblen gefunden. Auch wenn es manchmal gewollt ist, so ist diese Konstrukt doch verwirrend und meist ein Tippfehler.
MSG_AssignmentToForLoopParam=Zuweisung auf Parameter {0} einer for-Schleife
DN_org.netbeans.modules.java.hints.AssignmentIssues.assignmentToCatchBlockParameter=Zuweisung auf "catch"-Blockparameter
DESC_org.netbeans.modules.java.hints.AssignmentIssues.assignmentToCatchBlockParameter=Findet Zuweisungen auf Variablen, die als "catch"-Blockparameter definiert sind. Auch wenn es manchmal gewollt ist, kann dieses Konstrukt verwirrend sein.
MSG_AssignmentToCatchBlockParameter=Zuweisung auf "catch"-Blockparameter {0}
DN_org.netbeans.modules.java.hints.AssignmentIssues.assignmentToMethodParam=Zuweisung auf Methodenparameter
DESC_org.netbeans.modules.java.hints.AssignmentIssues.assignmentToMethodParam=Findet Zuweisungen auf Variablen, die als Methodenparameter deklariert sind. Es werden auch Inkremente und Dekremente der Variablen gefunden. Auch wenn es manchmal beabsichtigt ist, kann dieses Konstrukt verwirren und ist oftmals ein Tippfehler.
MSG_AssignmentToMethodParam=Zuweisung auf Methodenparameter {0}
DN_org.netbeans.modules.java.hints.AssignmentIssues.nestedAssignment=Eingebettete Zuweisung
DESC_org.netbeans.modules.java.hints.AssignmentIssues.nestedAssignment=Zeigt Zuweisungsausdr\u00fccke an, die in andere Ausdr\u00fccke eingebettet sind. Obwohl platzsparend, sind solche Ausdr\u00fccke verwirrend und versto\u00dfen gegen das Designprinzip, dass jede Anweisung exakt eine Sache tun soll.
MSG_NestedAssignment=Eingebettete Zuweisung  ''{0}''
DN_org.netbeans.modules.java.hints.AssignmentIssues.incrementDecrementUsed=Wert des In-/Dekrementausdrucks wird verwendet
DESC_org.netbeans.modules.java.hints.AssignmentIssues.incrementDecrementUsed=Findet Stellen, an denen In-/Dekrementausdr\u00fccke in andere Ausdr\u00fccke eingebettet sind. Obwohl platzsparend, sind solche Ausdr\u00fccke verwirrend und versto\u00dfen gegen das Designprinzip, dass jede Anweisung exakt eine Sache tun soll.
MSG_IncrementUsedAsExpression=Der Wert des Inkrementausdrucks ''{0}'' wird verwendet
MSG_DecrementUsedAsExpression=Der Wert des Dekrementausdrucks ''{0}'' wird verwendet
FIX_IncrementUsedAsExpression=Inkrementausdruck ''{0}'' extrahieren
FIX_DecrementUsedAsExpression=Dekrementausdruck ''{0}'' extrahieren
DN_org.netbeans.modules.java.hints.AssignmentIssues.replaceAssignWithOpAssign=Zuweisung durch Operator-Zuweisung ersetzbar
DESC_org.netbeans.modules.java.hints.AssignmentIssues.replaceAssignWithOpAssign=Zeigt Benutzung von Zuweisungen, die durch Operator-Zuweisung ersetzt werden k\u00f6nnen. Code mit Operator-Zuweisung ist m\u00f6glicherweise \u00fcbersichtlicher und theoretisch performanter.
MSG_ReplaceAssignmentWithOperatorAssignment=Zuweisung ''{0}'' kann durch Operator-Zuweisung ersetzt werden
FIX_ReplaceAssignmentWithOperatorAssignment=Ersetze Zuweisung ''{0}'' mit Operator-Zuweisung

#IncompatibleMask hint
DN_org.netbeans.modules.java.hints.IncompatibleMask=Inkompatible Maske
DESC_org.netbeans.modules.java.hints.IncompatibleMask=Diese Analyse zeigt alle Vorkommen von Bitmasken-Ausdr\u00fccken, die garantiert "false" ergeben. \u00dcberpr\u00fcfte Ausdr\u00fccke haben die Form (Var & Konstante1) == Konstante2 oder (Var | Konstante1) == Konstante2, wobei Konstante1 und Konstante2 verschiedene Bitmask-Konstanten sind.
MSG_IncompatibleMask=Unterschiedliche Masken: {0} ist immer 0

#OverridableMethodCallInConstructor hint
DN_org.netbeans.modules.java.hints.OverridableMethodCallInConstructor=Problematischer Aufruf im Konstruktor
DESC_org.netbeans.modules.java.hints.OverridableMethodCallInConstructor=Der Aufruf \u00fcberschreibbarer Methoden im Konstruktor kann problematisch sein, da im Moment des Aufrufs das Objekt noch nicht komplett initialisiert ist.
MSG_org.netbeans.modules.java.hints.OverridableMethodCallInConstructor=Aufruf einer \u00fcberschreibbaren Methode im Konstruktor
FIX_MakeMethod=Methode {1} {0} machen
FIX_MakeClass=Klasse {1} {0} machen

#PointlessBitwiseExpression hint
DN_org.netbeans.modules.java.hints.PointlessBitwiseExpression=Sinnloser Bit-Ausdruck
DESC_org.netbeans.modules.java.hints.PointlessBitwiseExpression=Diese Analyse zeigt alle Vorkommen sinnloser Bit-Ausdr\u00fccke. Solche Ausdr\u00fccke umfassen Und-, Oder- bzw. Schiebe-Operationen mit 0. Solche Audr\u00fccke k\u00f6nnen beim automatischen \u00dcberarbeiten entstehen, wenn es nicht beendet wurde, sie sind meist nicht das, was der Entwickler beabsichtigt hatte.
MSG_PointlessBitwiseExpression=Sinnloser Bit-Ausdruck
MSG_PointlessBitwiseExpression_fix=Konstante 0 sollte gel\u00f6scht werden

#LeakingThisInConstructor hint
DN_org.netbeans.modules.java.hints.LeakingThisInConstructor=\u00dcbergabe eines fragw\u00fcrdigen Parameters im Konstruktor
DESC_org.netbeans.modules.java.hints.LeakingThisInConstructor=Die Benutzung dieses Parameters im Konstruktor kann problematisch sein, da das Objekt nicht komplett initialisiert ist.
MSG_org.netbeans.modules.java.hints.LeakingThisInConstructor=Fehlendes this im Konstruktor

#ThreadDumpStack hint
DN_org.netbeans.modules.java.hints.ThreadDumpStack=Dump des Threadstacks
DESC_org.netbeans.modules.java.hints.ThreadDumpStack=Findet Nutzungen von Thread.dumpStack(). Oftmals handelt es sich dabei im tempor\u00e4re Debugginganweisungen, die entweder aus dem Produktivcode entfernt oder durch bessere Protokollierungsmechanismen ersetzt werden sollten.
MSG_ThreadDumpStack=Dump des Threadstacks
MSG_ThreadDumpStack_fix=Thread.dumpStack() sollte entfernt werden

#PrintStackTrace hint
DN_org.netbeans.modules.java.hints.PrintStackTrace=Ausgabe des Stacktrace
DESC_org.netbeans.modules.java.hints.PrintStackTrace=Findet argumentlose Nutzungen von Throwable.printStackTrace(). Dabei handelt es sich oft um tempor\u00e4re Debugginganweisungen, die entweder aus dem Produktivcode entfernt oder durch bessere Protokollierungsmechanismen ersetzt werden sollten.
MSG_PrintStackTrace=Ausgabe des Stacktrace
MSG_PrintStackTrace_fix=Throwable.printStackTrace() sollte entfernt werden

#SystemOut hint
DN_org.netbeans.modules.java.hints.SystemOut=System out / err
DESC_org.netbeans.modules.java.hints.SystemOut=Findet Nutzungen von System.out oder System.err. Dabei handelt es sich oft um tempor\u00e4re Debugginganweisungen, die entweder aus dem Produktivcode entfernt oder durch bessere Protokollierungsmechanismen ersetzt werden sollten.
MSG_SystemOut=System.out oder System.err werden oftmals nur als tempor\u00e4re Debugging-Anweisungen verwendet.
MSG_SystemOut_fix=Anweisung entfernen

#ObsoleteCollection hint
DN_org.netbeans.modules.java.hints.ObsoleteCollection=Veraltete Collection
DESC_org.netbeans.modules.java.hints.ObsoleteCollection=Findet Benutzungen von java.util.Vector oder java.util.Hashtable. Diese Klassen werden zwar noch unterst\u00fctzt, wurden aber bereits im JDK1.2 als veraltet markiert und sollten bei Neuentwicklungen nicht mehr verwendet werden.
MSG_ObsoleteCollection=Veraltete Collection

#StaticNonFinalUsedInInitialization hint
DN_org.netbeans.modules.java.hints.StaticNonFinalUsedInInitialization=In der Initialisierung wird eine nicht-final static Variable genutzt
DESC_org.netbeans.modules.java.hints.StaticNonFinalUsedInInitialization=Die Benutzung von nicht-final static Variablen kann problematisch sein, da deren Werte von der Reihenfolge der Initialisierungsanweisungen abh\u00e4ngt
MSG_org.netbeans.modules.java.hints.StaticNonFinalUsedInInitialization=Nutzung einer nicht-final static Variable w\u00e4hrend der Initialisierung

LBL_WarnHiddenStaticFields=Warnung, wenn das versteckte Feld "static" ist
TP_WarnHiddenStaticFields=Legt fest, ob eine Warnung kommt, wenn das versteckte Feld "static" ist

LBL_Javac_FINALLY=finally
