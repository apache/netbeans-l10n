# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
#
# Copyright 1997-2010 Oracle and/or its affiliates. All rights reserved.
#
# Oracle and Java are registered trademarks of Oracle and/or its affiliates.
# Other names may be trademarks of their respective owners.
#
# The contents of this file are subject to the terms of either the GNU
# General Public License Version 2 only ("GPL") or the Common
# Development and Distribution License("CDDL") (collectively, the
# "License"). You may not use this file except in compliance with the
# License. You can obtain a copy of the License at
# http://www.netbeans.org/cddl-gplv2.html
# or nbbuild/licenses/CDDL-GPL-2-CP. See the License for the
# specific language governing permissions and limitations under the
# License.  When distributing the software, include this License Header
# Notice in each file and include the License file at
# nbbuild/licenses/CDDL-GPL-2-CP.  Oracle designates this
# particular file as subject to the "Classpath" exception as provided
# by Oracle in the GPL Version 2 section of the License file that
# accompanied this code. If applicable, add the following below the
# License Header, with the fields enclosed by brackets [] replaced by
# your own identifying information:
# "Portions Copyrighted [year] [name of copyright owner]"
#
# Contributor(s):
#
# The Original Software is NetBeans. The Initial Developer of the Original
# Software is Sun Microsystems, Inc. Portions Copyright 1997-2007 Sun
# Microsystems, Inc. All Rights Reserved.
#
# If you wish your version of this file to be governed by only the CDDL
# or only the GPL Version 2, indicate your decision by adding
# "[Contributor] elects to include this software in this distribution
# under the [CDDL or GPL Version 2] license." If you do not indicate a
# single choice of license, a recipient has the option to distribute
# your version of this file under either the CDDL, the GPL Version 2 or
# to extend the choice of license to its licensees as provided above.
# However, if you add GPL Version 2 code and therefore, elected the GPL
# Version 2 license, then the option applies only if the new code is
# made subject to such option by the copyright holder.

BINARY_FILTER=Filtro de bin\u00e1rios
COMMENT_FILTER=Filtro de coment\u00e1rios
DEPENDENCY_FILTER=Filtro de depend\u00eancias
DSC_ElNotAvail=O elemento original que est\u00e1 sendo refatorado n\u00e3o est\u00e1 dispon\u00edvel. Ele foi exclu\u00eddo ou alterado significativamente. N\u00e3o \u00e9 poss\u00edvel coletar usos.
DSC_ElementNotResolved=N\u00e3o \u00e9 poss\u00edvel refatorar elementos n\u00e3o resolvidos
ERR_CannotMovePublicIntoSamePackage=N\u00e3o \u00e9 poss\u00edvel mover a classe p\u00fablica para o mesmo pacote.
ERR_ClasspathNotFound=Nenhum classpath definido para {0}.
# {0} - Class name.
ERR_ClassToMoveClashes=A classe "{0}" j\u00e1 existe no pacote de destino.
# {0} - Source Class name.
# {1} - Target Class name.
ERR_ClassToMoveClashesInner=O tipo "{0}" j\u00e1 existe no destino "{1}".
# {0} - ParameterName
ERR_GenericOptional=O par\u00e2metro {0} \u00e9 um tipo gen\u00e9rico, seu setter n\u00e3o pode ser opcional.
ERR_InlineAssignedOnce=A vari\u00e1vel foi designada mais de uma vez.
ERR_InlineMethodAbstract=N\u00e3o \u00e9 poss\u00edvel alinhar o m\u00e9todo abstrato.
ERR_InlineMethodInInterface=N\u00e3o \u00e9 poss\u00edvel alinhar o m\u00e9todo na interface.
ERR_InlineMethodMultipleReturn=N\u00e3o \u00e9 poss\u00edvel alinhar o m\u00e9todo com v\u00e1rias instru\u00e7\u00f5es de retorno em {0}.
ERR_InlineMethodNoLastReturn=A \u00faltima instru\u00e7\u00e3o n\u00e3o \u00e9 de retorno; n\u00e3o \u00e9 poss\u00edvel alinhar em {0}.
ERR_InlineMethodPolymorphic=N\u00e3o \u00e9 poss\u00edvel alinhar o m\u00e9todo polim\u00f3rfico.
ERR_InlineMethodRecursion=N\u00e3o \u00e9 poss\u00edvel alinhar o m\u00e9todo recursivo.
ERR_InlineMethodVoidReturn=N\u00e3o \u00e9 poss\u00edvel alinhar o m\u00e9todo com instru\u00e7\u00f5es de retorno sem o tipo de retorno.
ERR_InlineNotCompoundArrayInit=Declara\u00e7\u00f5es de arrays sem a palavra-chave "new" n\u00e3o s\u00e3o suportados.
ERR_InlineNotInIterator=N\u00e3o \u00e9 poss\u00edvel refatorar para o iterador de loop.
ERR_InlineNoVarInitializer=N\u00e3o \u00e9 poss\u00edvel localizar o inicializador de vari\u00e1vel.
ERR_InlineNullVarInitializer=N\u00e3o \u00e9 poss\u00edvel alinhar o literal nulo.
ERR_InlineWrongType=N\u00e3o \u00e9 poss\u00edvel refatorar este tipo de elemento: {0}.
ERR_InnerToOuter_ClassNameClash=A classe interna com o nome <b>{0}</b> j\u00e1 existe na classe de destino.
ERR_InvertMethodAbstract=N\u00e3o \u00e9 poss\u00edvel inverter o m\u00e9todo abstrato.
ERR_InvertMethodInInterface=N\u00e3o \u00e9 poss\u00edvel inverter o m\u00e9todo na interface.
ERR_InvertMethodPolymorphic=N\u00e3o \u00e9 poss\u00edvel inverter o m\u00e9todo polim\u00f3rfico.
# {0} - Method name
ERR_MoveAbstractMember=N\u00e3o \u00e9 poss\u00edvel mover o m\u00e9todo abstrato "{0}"
ERR_MoveFromClass=\u00c9 poss\u00edvel mover somente membros de um classe
ERR_MoveFromLibrary=N\u00e3o \u00e9 poss\u00edvel mover de uma biblioteca
ERR_MoveGenericField=N\u00e3o \u00e9 poss\u00edvel mover um campo gen\u00e9rico
# {0} - Method name
ERR_MoveMethodPolymorphic=N\u00e3o \u00e9 poss\u00edvel mover o m\u00e9todo polim\u00f3rfico "{0}"
ERR_MoveToLibrary=N\u00e3o \u00e9 poss\u00edvel mover para uma biblioteca
ERR_MoveToSameClass=O destino n\u00e3o pode ser igual \u00e0 classe de origem
ERR_MoveToSubClass=N\u00e3o \u00e9 poss\u00edvel mover para uma subclasse; talvez seja necess\u00e1rio utilizar a Refatora\u00e7\u00e3o p/ Inserir.
ERR_MoveToSuperClass=N\u00e3o \u00e9 poss\u00edvel mover para uma superclasse; talvez seja necess\u00e1rio utilizar a Refatora\u00e7\u00e3o p/ Retirar?
ERR_NoTargetFound=N\u00e3o \u00e9 poss\u00edvel localizar o destino para o qual mover.
ERR_NotClass=O elemento selecionado n\u00e3o \u00e9 uma classe ou interface de n\u00edvel superior.
ERR_NothingSelected=Nada selecionado para mover
# {0} - The file not of java type.
ERR_NotJava=O elemento selecionado n\u00e3o est\u00e1 definido em um arquivo java. {0}
ERR_ProjectNotOpened=N\u00e3o \u00e9 poss\u00edvel refatorar {0} que est\u00e1 definido fora de um projeto aberto.

# {0} - Member
# {1} - Type
ERR_PushDown_AlreadyExists={0} j\u00e1 existe em {1}.
# {0} - Member
# {1} - Type
ERR_PushDown_UsedInSuper={0} \u00e9 referenciado por {1}.
ERR_ReplaceAbstract=N\u00e3o \u00e9 Poss\u00edvel Substituir o Construtor em uma classe abstrata.
ERR_ReplacePrivate=N\u00e3o \u00e9 Poss\u00edvel Substituir o Construtor com Builder que \u00e9 privado.
ERR_ReplaceWrongInnerType=N\u00e3o \u00e9 Poss\u00edvel Substituir o Construtor com F\u00e1brica em classe interna n\u00e3o est\u00e1tica.
ERR_ReplaceWrongType=N\u00e3o \u00e9 Poss\u00edvel Substituir o Construtor com F\u00e1brica desse objeto. Um construtor tem que ser selecionado.
# --- SAFE DELETE REFACTORING ------------------------------------------------------
ERR_SafeDel=Ocorreu um erro ao excluir <b>{0}</b>
# {0} - VariableName
ERR_VarNotInBlockOrMethod=A vari\u00e1vel "{0}" n\u00e3o est\u00e1 dentro de um bloco ou declara\u00e7\u00e3o de m\u00e9todo.
IMPORT_FILTER=Filtro de importa\u00e7\u00f5es
# {0} - Shortcut text
INFO_PressAgain=Pressione {0} Mais uma Vez para Obter Caixa de Di\u00e1logo de Refatoramento
LBL_ParametersCheck=Verificando par\u00e2metros...
LBL_PreCheck=Inicializando dados...
LBL_Prepare=Preparar
LBL_ShowUsages=Mostrar Utiliza\u00e7\u00f5e&s...
ERR_ReferencesFound=Foram localizadas refer\u00eancias a elementos selecionados. Remova todas as refer\u00eancias a esses elementos a fim de excluir sua classe com seguran\u00e7a.
LBL_Usages=Usos
PLATFORM_FILTER=Filtro de plataformas
READ_FILTER=Filtro de leituras
READ_WRITE_FILTER=Filtro de Leituras/Grava\u00e7\u00f5es
SOURCE_FILTER=Filtro de Origens
TEST_FILTER=Filtro de testes
TXT_DelegatingMethod=Delegar m\u00e9todo
# {0} - File name
TXT_DeleteFile=Excluir arquivo {0}
WRITE_FILTER=Filtro de grava\u00e7\u00f5es
WRN_Implements=O m\u00e9todo {0} de {1} substitui o m\u00e9todo {0} de {2}.
ERR_SafeDel_FromReference=N\u00e3o \u00e9 poss\u00edvel chamar a Exclus\u00e3o Segura nas Refer\u00eancias de Classe/M\u00e9todo
ERR_SafeDel_InvalidType=A Exclus\u00e3o Segura s\u00f3 pode ser chamada em um M\u00e9todo, Campo ou Classe
ERR_OverridesAbstractMethod=O m\u00e9todo selecionado n\u00e3o pode ser exclu\u00eddo com seguran\u00e7a, pois ele implementa um m\u00e9todo abstrato {0}. 

# --- EXTRACT INTERFACE REFACTORING ------------------------------------------------
TXT_ExtractInterface_CreateIfc=Criar interface <b>{0}</b>.
TXT_ExtractInterface_Method=Criar declara\u00e7\u00e3o de m\u00e9todo <b>{0}</b> na nova interface.
TXT_ExtractInterface_MoveMethod=Mover m\u00e9todo <b>{0}</b> para a nova interface.
TXT_ExtractInterface_Field=Mover campo <b>{0}</b> para a nova interface.
TXT_ExtractInterface_Class=Mover classe interna <b>{0}</b> para a nova interface.
TXT_ExtractInterface_Implements=Mover <b>{0}</b> para a cl\u00e1usula extends da nova interface.
TXT_ExtractInterface_AddImplements=Adicionar <b>{0}</b> \u00e0 cl\u00e1usula implements/extends.
ERR_ElementNotAvailable=N\u00e3o foi poss\u00edvel resolver o elemento.
ERR_ExtractInterface_MembersNotAvailable=Nada a extrair.
ERR_ExtractInterface_WrongModifiers=O m\u00e9todo {0} deve ser p\u00fablico e n\u00e3o est\u00e1tico.
ERR_ExtractInterface_UnknownMember=O membro {0} n\u00e3o pode ser extra\u00eddo.

# --- EXTRACT SUPER CLASS REFACTORING ------------------------------------------------
ERR_ExtractSC_MustBeClass=O tipo selecionado deve ser uma classe (n\u00e3o \u00e9 poss\u00edvel executar esta opera\u00e7\u00e3o em um tipo de anota\u00e7\u00e3o, interface ou enum).
ERR_IntroduceLEWrongType=O tipo selecionado deve ser uma classe (n\u00e3o \u00e9 poss\u00edvel executar esta opera\u00e7\u00e3o em um tipo de anota\u00e7\u00e3o, interface ou enum).
ERR_IntroduceLEInnerType=O tipo selecionado n\u00e3o pode ter Tipos Internos acess\u00edveis publicamente.
# Illegal member (0 = member name)
ERR_ExtractSC_IllegalMember=O membro "{0}" n\u00e3o pode ser extra\u00eddo para uma superclasse. Ele n\u00e3o pertence ao tipo de c\u00f3digo-fonte.
ERR_ExtractSuperClass_MembersNotAvailable=Nada a extrair.
ERR_ExtractSuperClass_UnknownMember=O membro {0} n\u00e3o pode ser extra\u00eddo.
TXT_ExtractSC_CreateSC=Criar classe <b>{0}</b>.
TXT_ExtractSC_Method=Criar declara\u00e7\u00e3o de m\u00e9todo <b>{0}</b> na nova superclasse.
TXT_ExtractSC_Member=Mover <b>{0}</b> para a nova superclasse.
TXT_ExtractSC_AddExtends=Definir <b>{0}</b> para a cl\u00e1usula extend.

# --- PULL UP REFACTORING ------------------------------------------------------
# *** Pre-check ***
# No supertype
ERR_PullUp_NoSuperTypes=N\u00e3o \u00e9 poss\u00edvel retirar membros. O tipo selecionado n\u00e3o tem supertipos nos projetos abertos no momento.
# No member
ERR_PullUp_NoMembers=O tipo selecionado e os respectivos supertipos n\u00e3o t\u00eam membros que possam ser retirados.
# *** Fast parameters check
# No selected member
ERR_PullUp_NoMembersSelected=Nenhum membro foi selecionado para retirar.
# No target type selected
ERR_PullUp_NoTargetType=Nenhum supertipo foi selecionado.
# *** Parameters check
# Illegal target type
ERR_PullUp_IllegalTargetType=O tipo de destino n\u00e3o \u00e9 um supertipo do tipo de c\u00f3digo-fonte, ou o c\u00f3digo-fonte para o tipo de destino n\u00e3o est\u00e1 dispon\u00edvel.
# Illegal target type
ERR_PullUp_MemberTargetType=O membro "{0}" \u00e9 igual ao tipo de alvo.
# Illegal member (0 = member name)
ERR_PullUp_IllegalMember=O membro "{0}" n\u00e3o pode ser retirado. Ele n\u00e3o pertence ao tipo de c\u00f3digo-fonte ou a um dos supertipos do tipo de c\u00f3digo-fonte que s\u00e3o subtipos do tipo de destino.
# Member already exists in the target type (0 = member name)
ERR_PullUp_MemberAlreadyExists=O membro "{0}" j\u00e1 existe no tipo de destino.
# *** Refactoring element descriptions
# Add abstract method to the target type (0 = method name)
ERR_CannotPullupDuplicateMembers=N\u00e3o \u00e9 poss\u00edvel retirar dois membros com a mesma assinatura.
ERR_PullupNonPublicToInterface=O membro "{0}" est\u00e1 sendo movido para a interface, mas n\u00e3o \u00e9 p\u00fablico.
ERR_PullupStaticToInterface=O membro "{0}" n\u00e3o pode ser movido para a interface, ele \u00e9 est\u00e1tico.

TXT_PullUp_AddMethod=Adicionar m\u00e9todo abstrato: <b>{0}</b>
# Move member to the target type (0 = member name)
TXT_PullUp_Member=Mova <b>{0}</b> para o tipo de destino.

# --- PUSH DOWN REFACTORING ------------------------------------------------------
TXT_PushDown_Member=Copiar <b>{0}</b> para o tipo <b>{1}</b>.
TXT_PushDown_Remove=Remova o elemento <b>{0}</b>.
TXT_PushDown_Abstract=Tornar m\u00e9todo <b>{0}</b> abstrato.
TXT_PushDown_RelaxAccessModifier=Alterar modificador de <b>{0}</b> para <b>{1}</b>.
LBL_PushDown_private=privado
LBL_PushDown_package_private=pacote privado
LBL_PushDown_protected=protegido
ERR_PushDown_InvalidSource=N\u00e3o \u00e9 poss\u00edvel resolver a fonte selecionada: "{0}" -> "{1}".
ERR_PushDOwn_NoSubtype=N\u00e3o \u00e9 poss\u00edvel inserir membros. O tipo selecionado n\u00e3o tem subtipos nos projetos abertos no momento.
ERR_PushDown_NoMembers=O tipo selecionado n\u00e3o tem membros que possam ser inseridos.
ERR_PushDown_NoMembersSelected=Nenhum membro est\u00e1 selecionado para ser inserido.

# --- INNER TO OUTER REFACTORING ------------------------------------------------
ERR_InnerToOuter_MustBeInnerClass=O tipo selecionado deve ser um tipo interno (n\u00e3o \u00e9 poss\u00edvel executar esta opera\u00e7\u00e3o em um tipo de n\u00edvel superior).
ERR_InnerToOuter_FieldNameClash=O campo denominado <b>{0}</b> j\u00e1 existe nessa classe.
ERR_InnerToOuter_OuterUsed=A classe movida para o n\u00edvel externo usa membros de sua classe externa. Voc\u00ea deve deixar a refatora\u00e7\u00e3o criar uma vari\u00e1vel da inst\u00e2ncia mantendo a refer\u00eancia \u00e0 classe externa original.
ERR_InnerToOuter_InnerHidden=Um dos supertipos da classe de destino j\u00e1 define uma classe interna com o nome <b>{0}</b>.
TXT_InnerToOuter_MoveToOuter=Torne esta classe uma classe interna do <b>{0}</b>.
TXT_InnerToOuter_MoveToTop=Torne esta classe uma classe de n\u00edvel superior.
TXT_InnerToOuter_Rename=Renomeie esta classe para <b>{0}</b>.
TXT_InnerToOuter_AddReference=Adicionar um novo campo de inst\u00e2ncia denominado <b>{0}</b> apontando para a classe externa original e atualizar construtores da classe.
TXT_InnerToOuter_AddConstructor=Adicionar construtor, pois o construtor default n\u00e3o estar\u00e1 dispon\u00edvel na superclasse.
TXT_InnerToOuter_AddConstructorInvocation=Adicionar chamada expl\u00edcita de construtor, pois o construtor default n\u00e3o estar\u00e1 dispon\u00edvel na superclasse.
TXT_InnerToOuter_RelaxAccessRights=Alterar de privado para privado por pacote.
ERR_InnerToOuter_UseDeclareField=N\u00e3o \u00e9 poss\u00edvel refatorar "{0}". Utilize a op\u00e7\u00e3o "Declarar campo".
ERR_InnerToOuter_Anonymous=N\u00e3o \u00e9 poss\u00edvel refatorar classes an\u00f4nimas.
WRN_InitNoAccess=O inicializador de campo utiliza acessadores locais que n\u00e3o poder\u00e3o ser acessados
WRN_InlineChange=N\u00e3o \u00e9 seguro -- a funcionalidade do programa pode ser alterada.
WRN_InlineChangeReturn=N\u00e3o seguro - a express\u00e3o de retorno n\u00e3o \u00e9 usada em {0}.
WRN_InlineMethodMultipleLines=O corpo do m\u00e9todo possui muitas instru\u00e7\u00f5es, a refer\u00eancia n\u00e3o ser\u00e1 atualizada em {0}. Os c\u00f3digos-fonte n\u00e3o ser\u00e3o compilados ap\u00f3s a refatora\u00e7\u00e3o!
WRN_InlineNotAccessible={0} n\u00e3o pode ser acessado do {1}.
WRN_InnerToOuterRefToPrivate=A classe interna est\u00e1 utilizando a funcionalidade privada {0} que n\u00e3o poder\u00e1 ser acessada ap\u00f3s a refatora\u00e7\u00e3o
ERR_EmptyReferenceName=O nome da refer\u00eancia para a classe interna n\u00e3o pode ficar vazio.
ERR_OuterNameAlreadyUsed=O nome "{0}" j\u00e1 est\u00e1 sendo utilizado como um nome de campo em {1}.
# {0} - File displayname : line number
WRN_NoAccessor=Nenhum acessador localizado para chamar o m\u00e9todo em: {0}
# {0} - ParameterName
WRN_NODEFAULT=O setter do par\u00e2metro {0} \u00e9 opcional mas n\u00e3o possui um valor default.
WRN_OuterNameAlreadyUsed=O nome "{0}" j\u00e1 est\u00e1 sendo utilizado como um nome de campo em {1}.
ERR_InnerToOuter_OuterNameClash=O nome "{0}" j\u00e1 est\u00e1 sendo utilizado como um par\u00e2metro do construtor de {1}.
ERR_InnerToOuter_OuterNameClashSubtype=O nome {0} j\u00e1 est\u00e1 sendo utilizado no subtipo de {1} ({2}) como um par\u00e2metro do construtor.

# --- USE SUPERTYPE REFACTORING ------------------------------------------------------
TXT_UseSuperType=Utilize o Supertipo de <b>{0}</b> onde poss\u00edvel
TXT_UseSuperTypeVariable=Alterar tipo de <b>{0}</b> para <b>{1}</b>
TXT_UseSuperTypeReturnType=Alterar tipo de retorno de <b>{0}</b> para <b>{1}</b>
TXT_UseSuperTypeLocalVar=Alterar tipo de vari\u00e1vel(is) local(is) <b>{0}</b> para <b>{1}</b>
TXT_UseSuperTypeProblem=O tipo {0} n\u00e3o est\u00e1 vis\u00edvel no corpo de {1}
ERR_UseSuperType_InvalidElement=A op\u00e7\u00e3o Utilizar Supertipo s\u00f3 pode ser chamada em tipos v\u00e1lidos
ERR_UseSuperTypeNoSuperType=Nenhum supertipo selecionado.

# --- COPY CLASS ---------------------------------------------------------------
TXT_CopyClassToPackage=Criar uma nova classe {0} no pacote {1} como uma c\u00f3pia de {2}

# rename error messages
ERR_RenameWrongType=N\u00e3o \u00e9 poss\u00edvel renomear este tipo de objeto. O pacote Java, o m\u00e9todo, o campo ou a classe deve estar selecionado.
ERR_Overrides=Este m\u00e9todo substitui ou implementa m\u00e9todos em superclasses/interfaces. Eles tamb\u00e9m ser\u00e3o renomeados.
ERR_Overrides_Fatal=Este m\u00e9todo substitui ou implementa m\u00e9todos em superclasses/interfaces; portanto, seu nome n\u00e3o pode ser alterado.
ERR_Overrides_tree=Este m\u00e9todo substitui ou implementa um m\u00e9todo em {0}. Este m\u00e9todo tamb\u00e9m \u00e9 substitu\u00eddo ou implementado em {1}. Se voc\u00ea realmente deseja executar esta opera\u00e7\u00e3o, chame-a no m\u00e9todo em {2}.
ERR_IsOverridden=Existem m\u00e9todos em subclasses/implementadores de {0} que substituem ou implementam este m\u00e9todo. Eles tamb\u00e9m ser\u00e3o renomeados.
ERR_IsOverriddenOverrides=Os m\u00e9todos nas subclasses/implementa\u00e7\u00f5es de {0} que substituem ou implementam este m\u00e9todo tamb\u00e9m substituem ou implementam o m\u00e9todo nas superclasses/interfaces. Os c\u00f3digos-fonte n\u00e3o ser\u00e3o compilados ap\u00f3s a refatora\u00e7\u00e3o!
ERR_WillBeOverridden=Ap\u00f3s ser renomeado, o m\u00e9todo original "{0}" em {1} ser\u00e1 substitu\u00eddo pelo m\u00e9todo "{2}" em {3}.
ERR_WillBeOverridden_access=Ap\u00f3s ser renomeado, o m\u00e9todo original {0} em {1} ser\u00e1 substitu\u00eddo pelo m\u00e9todo "{2}" em {3} com menores privil\u00e9gios de acesso.
ERR_WillBeOverridden_static=Ap\u00f3s ser renomeado, o m\u00e9todo {0} original "{1}" em {2} ser\u00e1 substitu\u00eddo pelo {3} m\u00e9todo "{4}" em {5}.
ERR_WillBeOverridden_final=Ap\u00f3s ser renomeado, o m\u00e9todo original final "{0}" em {1} ser\u00e1 substitu\u00eddo pelo m\u00e9todo "{2}" em {3}.
ERR_WillOverride=Ap\u00f3s ser renomeado, o m\u00e9todo "{0}" em {1} substituir\u00e1 o m\u00e9todo original "{2}" em {3}.
ERR_WillOverride_access=Ap\u00f3s ser renomeado, o m\u00e9todo {0} em {1} substituir\u00e1 o m\u00e9todo original "{2}" em {3} com maiores privil\u00e9gios de acesso.
ERR_WillOverride_static=Ap\u00f3s ser renomeado, o {0} m\u00e9todo "{1}" em {2} substituir\u00e1 o {3} m\u00e9todo "{4}" original em {5}.
ERR_WillOverride_final=Ap\u00f3s ser renomeado, o m\u00e9todo "{0}" em {1} substituir\u00e1 o m\u00e9todo original final "{2}" em {3}.
ERR_NameNotChanged=O nome n\u00e3o foi modificado. Nenhuma altera\u00e7\u00e3o ser\u00e1 executada.
ERR_InvalidIdentifier="{0}" n\u00e3o \u00e9 um identificador Java v\u00e1lido.
ERR_InvalidPackage="{0}" n\u00e3o \u00e9 um identificador de pacote v\u00e1lido.
ERR_InvalidFolder="{0}" n\u00e3o \u00e9 um nome de pasta v\u00e1lido.
ERR_PackageExists=O pacote "{0}" j\u00e1 existe.
ERR_InnerClassClash=N\u00e3o \u00e9 poss\u00edvel renomear. A classe interna {0} j\u00e1 existe na classe {1}.
ERR_ClassClash=N\u00e3o \u00e9 poss\u00edvel refatorar. A classe {0} j\u00e1 existe na pasta {1}.
ERR_ClassPackageClash=N\u00e3o \u00e9 poss\u00edvel renomear. A pasta {0} j\u00e1 existe em {1}.
ERR_MethodClash=N\u00e3o \u00e9 poss\u00edvel renomear. O m\u00e9todo {0} com a mesma assinatura j\u00e1 existe na classe {1}.
ERR_FieldClash=N\u00e3o \u00e9 poss\u00edvel renomear. O campo {0} j\u00e1 existe na classe {1}.
ERR_LocVariableClash=N\u00e3o \u00e9 poss\u00edvel renomear. {0}
ERR_LabelClash=N\u00e3o \u00e9 poss\u00edvel renomear. O label {0} j\u00e1 est\u00e1 em uso.
ERR_Hides=O campo a ser renomeado oculta um campo em {0}.
ERR_WillHide=O novo campo ocultar\u00e1 um campo em {0}.
ERR_WillHidePrivate=O novo campo com acesso {0} ocultar\u00e1 um campo com acesso {1} em {2}.
ERR_NameNotSet=O nome n\u00e3o foi especificado.
ERR_CannotRenameFile=N\u00e3o \u00e9 poss\u00edvel renomear um elemento no arquivo da biblioteca: "{0}".
ERR_ResourceUnavailable=N\u00e3o \u00e9 poss\u00edvel renomear o m\u00e9todo "{0}". O arquivo de c\u00f3digo-fonte "{1}" n\u00e3o est\u00e1 dispon\u00edvel.
ERR_RenameNative=Tentativa de renomear m\u00e9todo nativo "{0}". Renomear um m\u00e9todo nativo pode causar um UnsatisfiedLinkError no runtime.
ERR_CannotRefactorThis=N\u00e3o \u00e9 poss\u00edvel refatorar "{0}".

#Rename package
TXT_RenamePackage=Renomear arquivo 

#where used error messages
ERR_WhereUsedWrongType=N\u00e3o \u00e9 poss\u00edvel pesquisar os usos deste tipo de objeto. \u00c9 necess\u00e1rio selecionar um elemento Java.

# move class/package error messages
ERR_TargetFolderNotSet=Um pacote alvo n\u00e3o foi especificado.
ERR_NoTarget=Uma classe de destino n\u00e3o foi especificada.
ERR_TargetNotResolved=A classe de destino n\u00e3o p\u00f4de ser resolvida.
ERR_TargetFolderNotJavaPackage=Uma pasta de destino n\u00e3o \u00e9 um pacote java.
ERR_SourceWithoutClass=O c\u00f3digo-fonte selecionado n\u00e3o cont\u00e9m classe.
ERR_AccessesPackagePrivateFeature=A classe "{0}" do mesmo pacote est\u00e1 usando a funcionalidade "{1}" da classe que voc\u00ea deseja mover ("{2}").
ERR_AccessesPackagePrivateClass=A classe "{0}" do mesmo pacote est\u00e1 utilizando a classe {1} que voc\u00ea deseja mover ("{2}").
ERR_AccessesPackagePrivateConstructor=A classe "{0}" do mesmo pacote est\u00e1 utilizando o construtor {1} declarado na classe que voc\u00ea deseja mover ("{2}").
ERR_AccessesPackagePrivateFeature2=A classe que voc\u00ea deseja mover ("{0}") est\u00e1 usando a funcionalidade "{1}" da classe "{2}" do mesmo pacote.
ERR_AccessesPackagePrivateClass2=A classe que voc\u00ea deseja mover ("{0}") est\u00e1 utilizando a {1} classe ("{2}") do mesmo pacote.
ERR_AccessesPackagePrivateConstructor2=A classe que voc\u00ea deseja mover ("{0}") est\u00e1 utilizando o construtor {1} declarado na classe ("{2}") do mesmo pacote.
ERR_PackageIsReadOnly=O pacote "{0}" \u00e9 somente para leitura.
ERR_ClassToCopyClashes=A classe "{0}" j\u00e1 existe no pacote de destino.
ERR_ClassesToCopyClashes=Um ou mais nomes de classes j\u00e1 est\u00e3o sendo utilizados no pacote de destino, eles ser\u00e3o renomeados.
ERR_ClassToMoveInDefaultPackage=Depois de mover, n\u00e3o ser\u00e1 poss\u00edvel importar classes no pacote default original.
ERR_MovingClassToDefaultPackage=Se a classe for movida para o pacote default, as classes de outros pacotes n\u00e3o poder\u00e3o importar as classes movidas.
ERR_MovingMemberToDefaultPackage=Se o membro for movido para uma classe do pacote default, as classes de outros pacotes n\u00e3o poder\u00e3o fazer refer\u00eancia ao membro movido.
ERR_FileAlreadyExists=O arquivo {0} j\u00e1 existe no pacote {1}.
ERR_PackageMovesToItself=O pacote pai foi selecionado como destino. N\u00e3o existe altera\u00e7\u00e3o a ser executada.
ERR_CannotMovePackageToSubpackage=Um pacote n\u00e3o pode ser movido para um destes subpacotes ou para si mesmo.
ERR_DefaultPackageCannotBeMoved=O pacote default n\u00e3o pode ser movido.
ERR_CannotMoveFile=N\u00e3o \u00e9 poss\u00edvel mover o arquivo da biblioteca: "{0}".
ERR_MissingProjectDeps=H\u00e1 refer\u00eancias no projeto "{0}" a arquivos movidos, mas o projeto de origem "{0}" n\u00e3o depende do projeto de destino "{1}". Os projetos n\u00e3o precisam ser compilados.
ERR_MemberMissingProjectDeps=O projeto de origem "{0}" n\u00e3o depende do projeto de destino "{1}", mas h\u00e1 refer\u00eancias no projeto "{0}" aos membros movidos. Os projetos n\u00e3o ser\u00e3o compilados.

# encapsulate field error messages
ERR_EncapsulateWrongType=N\u00e3o \u00e9 poss\u00edvel encapsular este tipo de objeto. \u00c9 necess\u00e1rio selecionar um campo.
ERR_EncapsulateNoFields=Nenhum campo localizado em {0}.
ERR_EncapsulateInIntf=N\u00e3o \u00e9 poss\u00edvel encapsular um campo da interface.
ERR_EncapsulateMethods=Os nomes de m\u00e9todos getter e setter devem ser nomes de m\u00e9todo v\u00e1lidos.
ERR_EncapsulateMethodsAccess=A acessibilidade de m\u00e9todos criados \u00e9 privada, mas alguns campos selecionados s\u00e3o referenciados de outros c\u00f3digos-fonte.
ERR_EncapsulateMethodsDefaultAccess=A refatora\u00e7\u00e3o pode quebrar seu c\u00f3digo, pois os m\u00e9todos criados t\u00eam uma acessibilidade default, mas alguns campos selecionados s\u00e3o referenciados em outros c\u00f3digos-fonte.
ERR_EncapsulateInsideAssignment=N\u00e3o \u00e9 poss\u00edvel substituir {0} em {1} por void setter em {2}.
ERR_EncapsulateInsideConstructor=A acessibilidade do campo {0} \u00e9 privada, mas o campo \u00e9 referenciado no construtor de classes {1}.
ERR_EncapsulateWrongGetter=O getter {0} j\u00e1 existe, mas com tipo de retorno {1} incorreto.
ERR_EncapsulateWrongSetter=O setter {0} j\u00e1 existe, mas com tipo de retorno incorreto {1}.
ERR_EncapsulateAccessGetter=O getter {0} substituir\u00e1 o m\u00e9todo na classe {1}, mas seus privil\u00e9gios de acesso s\u00e3o inferiores.
ERR_EncapsulateAccessSetter=O setter {0} substituir\u00e1 o m\u00e9todo na classe {1}, mas seus privil\u00e9gios de acesso s\u00e3o inferiores.
ERR_EncapsulateAccessOverGetter=O getter {0} ser\u00e1 substitu\u00eddo na classe {1} com privil\u00e9gios de acesso inferiores.
ERR_EncapsulateAccessOverSetter=O setter {0} ser\u00e1 substitu\u00eddo na classe {1} com privil\u00e9gios de acesso inferiores.
ERR_EncapsulateNothingSelected=Nada a encapsular. \u00c9 necess\u00e1rio marcar alguma caixa de sele\u00e7\u00e3o.
ERR_EncapsulatePropertyVetoException=O m\u00e9todo gera a PropertyVetoException que deve ser tratada.

# change method signature error messages
ERR_MethodOverrides=O m\u00e9todo substitui ou implementa m\u00e9todos em superclasses/interfaces.
ERR_MethodIsOverridden=Existem m\u00e9todos em subclasses ou implementadores de {0} que substituem ou implementam o m\u00e9todo.
WRN_MethodIsOverridden=Existem m\u00e9todos em subclasses ou implementa\u00e7\u00f5es de {0} que substituir\u00e3o ou implementar\u00e3o o m\u00e9todo.
ERR_HasVarArg=Voc\u00ea n\u00e3o pode utilizar a refatora\u00e7\u00e3o Alterar Par\u00e2metros do M\u00e9todo em m\u00e9todos com argumentos vari\u00e1veis.
ERR_newpar=Voc\u00ea deve fornecer {0} para todos os novos par\u00e2metros.
ERR_parname=nome do par\u00e2metro
ERR_partype=tipo de par\u00e2metro
WRN_canNotResolve=N\u00e3o \u00e9 poss\u00edvel solucionar o tipo {0} para a vari\u00e1vel {1}. \u00c9 poss\u00edvel que os c\u00f3digos-fonte n\u00e3o sejam compilados ap\u00f3s a refatora\u00e7\u00e3o!
ERR_canNotResolve=N\u00e3o \u00e9 poss\u00edvel resolver o tipo para {0}.
WRN_canNotResolveReturn=N\u00e3o \u00e9 poss\u00edvel resolver o tipo de retorno {0}. \u00c9 poss\u00edvel que os c\u00f3digos-fonte n\u00e3o sejam compilados ap\u00f3s a refatora\u00e7\u00e3o!
ERR_NoReturn=\u00c9 necess\u00e1rio fornecer um tipo de retorno.
WRN_isNotAssignable=Valores antigos do par\u00e2metro de tipo {0} n\u00e3o podem ser designados a {1}. \u00c9 poss\u00edvel que os c\u00f3digos-fonte n\u00e3o sejam compilados ap\u00f3s a refatora\u00e7\u00e3o!
ERR_pardefv=valores default
ERR_existingMethod=O m\u00e9todo {0} com a mesma assinatura j\u00e1 existe na classe {1}.
WRN_wideningConversion=O m\u00e9todo {0} com a mesma assinatura (por amplia\u00e7\u00e3o) j\u00e1 existe na classe {1}. O comportamento pode ser alterado.
ERR_existingConstructor=O construtor {0} com a mesma assinatura j\u00e1 existe na classe {1}.
ERR_existingConstr=N\u00e3o \u00e9 poss\u00edvel alterar a assinatura. Um construtor com a mesma assinatura j\u00e1 existe na classe {0}.
ERR_NoValues=Voc\u00ea deve fornecer valores para os novos par\u00e2metros.
ERR_DuplicateName=Nome de par\u00e2metro duplicado ({0}).
ERR_NameAlreadyUsed=O nome "{0}" j\u00e1 est\u00e1 sendo utilizado como um nome de vari\u00e1vel local.
ERR_NameAlreadyUsedField=O nome "{0}" j\u00e1 est\u00e1 sendo utilizado como um nome de campo.
ERR_ParamAlreadyUsed=O nome "{0}" j\u00e1 est\u00e1 sendo utilizado como um nome de par\u00e2metro.
ERR_CannotChangeModifiers=N\u00e3o \u00e9 poss\u00edvel alterar modificadores do m\u00e9todo na interface.
ERR_StrongAccMod=Voc\u00ea alterou o modificador de acesso para {0}. O m\u00e9todo n\u00e3o poder\u00e1 ser acessado por algumas refer\u00eancias em {1}. Os c\u00f3digos-fonte n\u00e3o ser\u00e3o compilados ap\u00f3s a refatora\u00e7\u00e3o!!
ERR_WeakerAccess=O m\u00e9todo {0} com a mesma assinatura na classe {1} tem privil\u00e9gios de acesso inferiores.
ERR_existingReturnType=O m\u00e9todo {0} com a mesma assinatura na classe {1} tem um tipo de retorno diferente, {2} -> {3}

ERR_ChangeParamsWrongType=N\u00e3o \u00e9 poss\u00edvel alterar os par\u00e2metros deste objeto. Um m\u00e9todo ou o construtor deve estar selecionado.
MSG_NothingToFind=Voc\u00ea n\u00e3o selecionou um item para pesquisa. Selecione Localizar Usos, Localizar M\u00e9todos de Substitui\u00e7\u00e3o ou ambos.
ERR_CannotRefactorLibraryClass=N\u00e3o \u00e9 poss\u00edvel refatorar a classe "{0}" da biblioteca.
ERR_MethodsInAnnotationsNotSupported=os membros da @interface podem n\u00e3o ter par\u00e2metros.
ERR_CannnotRefactorLibrary=N\u00e3o \u00e9 poss\u00edvel alterar par\u00e2metros de "{0}", o que substitui o m\u00e9todo da classe de biblioteca.

ERR_VarargsFinalPosition=Os varargs s\u00f3 podem ser usados na posi\u00e7\u00e3o final do argumento.
ERR_FindUsagesArrayType=N\u00e3o \u00e9 poss\u00edvel localizar usos em []

ERR_DollarWarning=O caractere $ deve ser utilizado apenas no c\u00f3digo gerado mecanicamente.
ERR_UpperCaseWarning=A primeira letra do tipo Java deve ser mai\u00fascula.

TAG_Deprecated=@obsoleto(a) Movido(a) para '{'@link {0}'}'

ERR_NoFactory=Nenhum nome de m\u00e9todo de f\u00e1brica especificado.
ERR_NotIdentifier="{0}" n\u00e3o \u00e9 um identificador.
ERR_FileExists=O arquivo {0} j\u00e1 existe.

